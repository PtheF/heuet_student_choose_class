# 并发场景-学生抢课系统
> create by 陈HL_pthef on 2022/05/11

## 1. 为什么写
学生管理系统，亦或者是教务系统，这种东西一直以来都是计算机学生的必备项目，估计很多人都用这玩意水过课设（毕设估计没法水）。

但是我估计大部分人都是在就会增删改查的时候，写过这个东西，但凡会的东西多一点，也就把这玩意抛弃了，不会再碰这种什么学生管理系统什么图书馆管理系统。

最近我又学了Redis，学习了一些轻量级的运用Redis解决并发问题的方案，但是光学了，没用过。正好，这学期选了个微信小程序，微信小程序有个课设，我就想着通过这个机会把我刚学的东西练一练。

## 2. 创新
说实话，教务系统或者这种抢课系统，乍一听似乎没有那么难做，但是仔细想想就会发现问题。我校的抢课系统一直很卡，不过1万人在线系统就几乎崩溃，结合最近学的Redis，突然发现：哎，这不就是个秒杀场景么。

什么叫秒杀，我个人理解，就是极短时间内有大量请求进入服务器，尝试做增删改查，对服务器造成巨大压力的场景就是秒杀场景。而大部分人写的抢课系统，我估计（我没写过教务系统，太没意思了）都是直接操作数据库，比如一个请求进来，要对课程a的余量-1，这个时候就会直接走数据库执行update操作，那这家伙，别说10w 100w 请求了，就是1w 请求来了，数据库也高低卡俩小时。

所以这次，我重新回到起点，来做这个看似简单到不能再简单的抢课系统，但是这回我要用我最近学到的新东西，来尝试解决并发问题，让 一万 个请求进来我的服务也可以轻松驾驭。

## 3. 技术

### 3.1 前端
前端就是用微信小程序，毕竟是微信课设

### 3.2 后端

- Java 相关框架
- JWT 令牌
- MySQL数据库
- Redis

## 4. 启动

### 4.1 Redis
首先，你至少有一个 版本 > 5 的Redis，是不是集群无所谓，单Redis也行，但是版本一定 >5，因为 Redis 的Stream在5以后才有。

然后，执行下面这条命令来创建消息队列和消费者组：
```
XGROUP CREATE {rob_class}:stream:rob rob_class_handler 0 MKSTREAM
```
剩下的不要管，缓存不用手动预热

### 4.2 MySQL
导入数据库，数据库是env目录下的rob_class.sql。创建rob_class数据库，并将数据导入即可。

注意，该数据库里面的学生选课信息非空，项目启动时会自动清理，复原数据库。

所有的密码都是123456.

### 4.3 启动后端
修改代码中的配置信息：
- yml文件中的redis配置信息和jdbc配置信息
- cn.chl.robClass.config.RedissonConfig 文件中的配置信息
- cn.chl.robClass.config.CacheInitial 中的缓存预热，稍微看一看，第一次启动不需要改

给你的IDE安装lombok插件。这个可能需要，因为我的代码中使用了lombok的@Slf4j，可能不装lombok代码没法正常编译。

直接启动SpringBoot项目即可，启动时会卡一会，因为要缓存预热。

### 4.4 前端
使用微信开发工具打开项目，修改所有的请求路径为你的后端路径（默认就是请求localhost，如果后端和前端运行在一台电脑上，那这个不用改）。

涉及到修改的文件如下：
- index.js
- myClass.js
- selectClass.js


## 5. 流程
抢课的流程我就直接按着学校的来做。

我校的抢课机制如下：首先大致分为两类，选修课和体育课，选修课没有容量限制，随便选，加入课程容量是100，抢课的时候可以一大堆人直接选到400，选完课之后，学校会踢人。体育课不一样，体育课是真的有余量，啥时候选完啥时候没，不能超选。所以这么来看，抢体育课是一个标准秒杀，得考虑操作原子性，避免出现超选和一人多课的问题。

所以，系统的整体流程如下：

1. 前端携带用户学号和密码登录，后端查询用户信息(尽量从缓存中查)，比对密码，生成JWT令牌，将用户信息和令牌返回给前端。
2. 前端查询当前用户的可选课程，这个过程也是查缓存，尽量不走数据库。
3. 用户发起抢课请求，发送一个 {课程id，课程类型}的 json 到后端
4. 后端收到请求，执行Lua脚本：
   - 通过Redis的 课程成员集合 来判断用户是否已选过该课，如果已选，返回 1
   - 如果当前课程是体育课，判断该课程是否已经满员，如果满员，返回 2
   - 前面两步验证成功，则做如下操作：
     - Redis中当前课程余量数-1
     - Redis中当前课程已选人数+1
     - Redis中当前课程成员集合添加当前用户id
     - Redis中当前用户的已选课程集合添加当前课程id
     - 向消息队列中发送 {抢课记录id, 学号, 课程号} 抢课消息
   - 最后脚本返回 0，表示当前用户抢课成功
   - 以上所有流程因为是Lua脚本，所以保证原子性，不会出现并发安全问题
5. 后端接收Lua脚本返回码，根据不同的返回值，直接给前端对应的响应信息
6. 后端消息队列监听器工作，监听消息队列，接收抢课消息，异步的根据抢课消息写入数据库
7. 用户查询自己的已选课程，后端从Redis的 用户已选课程课程集合 中拿到所有课程ID，从缓存中得到相应的课程信息然后返回
8. 登录-查课-抢课-自查 流程完毕


## 6. 测试

功能完成后开始进行性能测试。

### 6.1 测试工具
使用JMeter工具进行并发测试。测试文件放在jmeter目录下。

### 6.2 登陆测试
对服务发起五万次登录请求

未使用缓存效果如下：

| 线程数x每个线程请求数 | 总耗时(s) | 最大响应时间(ms) | 平均耗时(ms) | 吞吐量 |
|----------------------|----------|------------------|-------------|--------|
| 1000 x 50            |  39      | 1486             | 774         | 1264   |
| 5000 x 10            |  51      | 6127             | 4785        | 960    |
| 10000 x 5            |  72      | 63093            | 11125       | 688    |


使用缓存效果如下：

| 线程数x每个线程请求数 | 总耗时(s) | 最大响应时间(ms) | 平均耗时(ms) | 吞吐量 |
|----------------------|----------|------------------|-------------|--------|
| 1000 x 50            |  12      | 1458             |   227       | 4175   |
| 5000 x 10            |  14      | 2618             |   981       | 3584   |
| 10000 x 5            |  20      | 4865             |   1238      | 2444   |

可以看出用不用缓存的区别差的特别多，使用缓存时系统吞吐量是不用缓存的四倍，响应时间更是差的不是一星半点。

使用缓存时，在 10000 x 5 的情境下，可以在20秒内相应所有请求，平均耗时1.2秒。而不使用缓存时，同样情景下，需要72秒，平均耗时高达11.1秒。

### 6.3 测试抢课
抢课的话就不设置对照试验了，登录可以设置对照是因为登录时查询用户 确实是缓存，如果Redis没有还是会走数据库的。但是抢课真不一样，抢课很大一部分逻辑我直接放在了Redis上，相当于Redis缓存已经和业务耦合到一起了，想分离来做对照的话，就得重新写一套不用Redis的抢课逻辑。

同时我这里就不做多次重复试验了，因为测试一次至少耗时8分钟。

5000线程，每个线程10个请求 的场景下，抢课业务测试结果如下：

| 总耗时(s) | 最小响应时间(ms) | 最大响应时间(ms) | 平均耗时(ms) | 吞吐量 |
|-----------|-----------------|-----------------|-------------|--------|
| 30        |  6              |  7896           | 3041        | 1443   |

因为我的抢课是异步抢课，这个只是对前端的响应时间，响应结束后，后端服务又花费8分钟处理所有的抢课消息写入数据库。

虽然耗费8分钟，但是好歹服务还能进行，不至于把数据库玩垮，服务玩崩，所以整体效果还是不错的。

这是用的是Redis的Stream做消息队列，真实生产环境我觉得可以使用更专业的MQ产品，比如RabbitMQ。

### 6.4 正确性
得益于Lua脚本和分布式锁，目前系统没有任何并发问题，抢课测试完成后，查看课程容量表，发现体育课的余量全部是0，没有发生"超选"情况，同时得益于分布式锁，避免了同一个用户同时请求一个接口导致的"一人一课" 问题。

查看抢课记录表，发现记录数为21682，结果正确，虽然发了五万条请求，但是因为体育课不能超选，所以最后实际发送的抢课消息为21682，证明系统稳定性良好。

## 7. 不足
该系统还是有很多不足的，毕竟做的时间很短。周三留的课设，周六写完了，今天周日开始写文档打包环境上生产传git。整个小项目做了4天，很多问题没有考虑到，或是考虑到了，但是时间有限，懒得改：

- 系统没有做分页查询，未来的数据量会很大，不做分页麻烦更大
- 用户权限没有设计，前后端认证只是采用了最简单的JWT，没有使用更加安全合理的Shiro + JWT + Redis 的AccessToken RefreshToken 机制，接口没有做鉴权。
- 数据库设计混乱，时间有限，数据库就咋方便咋来了，很多设计并不合理
- 系统内部实体混乱，大量的VO PO，我都快看不懂了

## 8. 生产环境下的问题
我这套系统目前只是在我的本机上跑，我的环境是：
- 单个MySQL，放在虚拟机上
- 三主三从Redis集群，分布在三台虚拟机上
- 单个SpringBoot 服务

生产环境肯定逻辑要比我这套复杂得多，但是环境肯定得比我好，除非学校服务器是拼多多拼的。

个人觉得抢课，归根到底还是一个查询密集场景，因为大部分人不会像我测试那样，一瞬间看着个课就抢，大部分人主要还是查，查完了看一看选一选，看着合适的，偶尔抢一下。至于体育课，那确实是实打实的秒杀，但是抢体育课的人，只有大一和大二的，大约也就8000人，直接异步就好了。所以工作重心应该是如何合理的构建缓存。

所以查询密集，那就上缓存呗，抢课期间，课程的一些多变信息比如课程余量等，就直接放在Redis，至于其他的信息，短时间内也不会变，所以这也是一个弱一致性场景，双写一致性基本不用考虑。Redis不够用那就上多级缓存，把Redis搭成集群搞分布式缓存，然后为了应对第二天的抢课，提前一天将热点数据存入缓存呗，缓存预热呗。而且学校的服务器肯定比我的机子好，只要操作得当我觉得抗住一万次请求应该不是问题。但是年年选课年年卡，选个课，从8点，卡到9点，甚至10点，一个乒乓球，49个容量，从8点秒杀，秒到8点半，居然还没秒完，那我只能合理推断学校技术不行。